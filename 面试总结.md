# 什么是线程安全，举例说明

线程安全  就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。
线程不安全  就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

线程安全问题都是由[全局变量](http://baike.baidu.com/view/261041.htm)及[静态变量](http://baike.baidu.com/view/675642.htm)引起的。

若每个线程中对[全局变量](http://baike.baidu.com/view/261041.htm)、[静态变量](http://baike.baidu.com/view/675642.htm)只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑[线程同步](http://baike.baidu.com/view/6501899.htm)，否则的话就可能影响线程安全。



# 乐观锁和悲观锁

乐观锁：

总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现。

 **version方式**：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

核心SQL代码：

```
update table set x=x+1, version=version+1 where id=#{id} and version=#{version};  
```

 **CAS操作方式：**即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。

悲观锁：

 总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。



# RBAC 的表结构设计

- 2.1、用户表
- 2.2、角色表
- 2.3、权限表
- 2.4、用户角色（关系）表
- 2.5、角色权限（关系）表

# postgres优势



# java排查问题常用的命令

tail 、jps、 jinfo 、jstat、 ps 、netstat，top



# kafka集群



# redis存储对象



# java笔记--关于线程同步7种同步方式

**为何要使用同步？**     java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 
    将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用， 
    从而保证了该变量的唯一性和准确性。

 

**1.同步方法** 
    即有synchronized关键字修饰的方法。 
    由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 
    内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

​    代码如： 
    public synchronized void save(){}

  ` 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类`

 

**2.同步代码块**     即有synchronized关键字修饰的语句块。 
    被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

​    代码如： 
    synchronized(object){ 
    }

​    注：同步是一种高开销的操作，因此应该尽量减少同步的内容。 
    通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 
    代码实例： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
package com.xhj.thread;

    /**
     * 线程同步的运用
     * 
     * @author XIEHEJUN
     * 
     */
    public class SynchronizedThread {

        class Bank {

            private int account = 100;

            public int getAccount() {
                return account;
            }

            /**
             * 用同步方法实现
             * 
             * @param money
             */
            public synchronized void save(int money) {
                account += money;
            }

            /**
             * 用同步代码块实现
             * 
             * @param money
             */
            public void save1(int money) {
                synchronized (this) {
                    account += money;
                }
            }
        }

        class NewThread implements Runnable {
            private Bank bank;

            public NewThread(Bank bank) {
                this.bank = bank;
            }

            @Override
            public void run() {
                for (int i = 0; i < 10; i++) {
                    // bank.save1(10);
                    bank.save(10);
                    System.out.println(i + "账户余额为：" + bank.getAccount());
                }
            }

        }

        /**
         * 建立线程，调用内部类
         */
        public void useThread() {
            Bank bank = new Bank();
            NewThread new_thread = new NewThread(bank);
            System.out.println("线程1");
            Thread thread1 = new Thread(new_thread);
            thread1.start();
            System.out.println("线程2");
            Thread thread2 = new Thread(new_thread);
            thread2.start();
        }

        public static void main(String[] args) {
            SynchronizedThread st = new SynchronizedThread();
            st.useThread();
        }

    }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**3.使用特殊域变量(volatile)实现线程同步**

​    a.volatile关键字为域变量的访问提供了一种免锁机制， 
    b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 
  `  c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 `
   ` d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 `
    例如： 
        在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。 
    代码实例： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
      //只给出要修改的代码，其余代码与上同
        class Bank {
            //需要同步的变量加上volatile
            private volatile int account = 100;

            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized 
            public void save(int money) {
                account += money;
            }
        ｝
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

​    注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 
    用final域，有锁保护的域和volatile域可以避免非同步的问题。 
**4.使用重入锁实现线程同步**

​    在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 
    ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 
    它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力

​    ReenreantLock类的常用方法有：

​        ReentrantLock() : 创建一个ReentrantLock实例 
        lock() : 获得锁 
        unlock() : 释放锁 
    注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 
    例如： 
        在上面例子的基础上，改写后的代码为: 
    代码实例： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//只给出要修改的代码，其余代码与上同
        class Bank {
            
            private int account = 100;
            //需要声明这个锁
            private Lock lock = new ReentrantLock();
            public int getAccount() {
                return account;
            }
            //这里不再需要synchronized 
            public void save(int money) {
                lock.lock();
                try{
                    account += money;
                }finally{
                    lock.unlock();
                }
                
            }
        ｝
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

​    注：关于Lock对象和synchronized关键字的选择： 
        a.最好两个都不用，使用一种java.util.concurrent包提供的机制， 
            能够帮助用户处理所有与锁相关的代码。 
        b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 
      ` c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 `
**5.使用局部变量实现线程同步**     如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 
    副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

 

​    ThreadLocal 类的常用方法

 

​    ThreadLocal() : 创建一个线程本地变量 
    get() : 返回此线程局部变量的当前线程副本中的值 
    initialValue() : 返回此线程局部变量的当前线程的"初始值" 
    set(T value) : 将此线程局部变量的当前线程副本中的值设置为value

 

​    例如： 
        在上面例子基础上，修改后的代码为： 
    代码实例： 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//只改Bank类，其余代码与上同
        public class Bank{
            //使用ThreadLocal类管理共享变量account
            private static ThreadLocal<Integer> account = new ThreadLocal<Integer>(){
                @Override
                protected Integer initialValue(){
                    return 100;
                }
            };
            public void save(int money){
                account.set(account.get()+money);
            }
            public int getAccount(){
                return account.get();
            }
        }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

​    注：ThreadLocal与同步机制 
        a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 
        b.前者采用以"空间换时间"的方法，后者采用以"时间换空间"的方式

 

 

 

**6.使用阻塞队列实现线程同步**

 

> ​    前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 
>     使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 
>     本小节主要是使用**LinkedBlockingQueue<E>**来实现线程的同步 
>     LinkedBlockingQueue<E>是一个基于已连接节点的，范围任意的blocking queue。 
>     队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~ 
>    **LinkedBlockingQueue 类常用方法** 
>     LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue 
>     put(E e) : 在队尾添加一个元素，如果队列满则阻塞 
>     size() : 返回队列中的元素个数 
>     take() : 移除并返回队头元素，如果队列空则阻塞 
>    **代码实例：** 
>         实现商家生产商品和买卖商品的同步

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 package com.xhj.thread;
 2 
 3 import java.util.Random;
 4 import java.util.concurrent.LinkedBlockingQueue;
 5 
 6 /**
 7  * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用
 8  * 
 9  * @author XIEHEJUN
10  * 
11  */
12 public class BlockingSynchronizedThread {
13     /**
14      * 定义一个阻塞队列用来存储生产出来的商品
15      */
16     private LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>();
17     /**
18      * 定义生产商品个数
19      */
20     private static final int size = 10;
21     /**
22      * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程
23      */
24     private int flag = 0;
25 
26     private class LinkBlockThread implements Runnable {
27         @Override
28         public void run() {
29             int new_flag = flag++;
30             System.out.println("启动线程 " + new_flag);
31             if (new_flag == 0) {
32                 for (int i = 0; i < size; i++) {
33                     int b = new Random().nextInt(255);
34                     System.out.println("生产商品：" + b + "号");
35                     try {
36                         queue.put(b);
37                     } catch (InterruptedException e) {
38                         // TODO Auto-generated catch block
39                         e.printStackTrace();
40                     }
41                     System.out.println("仓库中还有商品：" + queue.size() + "个");
42                     try {
43                         Thread.sleep(100);
44                     } catch (InterruptedException e) {
45                         // TODO Auto-generated catch block
46                         e.printStackTrace();
47                     }
48                 }
49             } else {
50                 for (int i = 0; i < size / 2; i++) {
51                     try {
52                         int n = queue.take();
53                         System.out.println("消费者买去了" + n + "号商品");
54                     } catch (InterruptedException e) {
55                         // TODO Auto-generated catch block
56                         e.printStackTrace();
57                     }
58                     System.out.println("仓库中还有商品：" + queue.size() + "个");
59                     try {
60                         Thread.sleep(100);
61                     } catch (Exception e) {
62                         // TODO: handle exception
63                     }
64                 }
65             }
66         }
67     }
68 
69     public static void main(String[] args) {
70         BlockingSynchronizedThread bst = new BlockingSynchronizedThread();
71         LinkBlockThread lbt = bst.new LinkBlockThread();
72         Thread thread1 = new Thread(lbt);
73         Thread thread2 = new Thread(lbt);
74         thread1.start();
75         thread2.start();
76 
77     }
78 
79 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

注：BlockingQueue<E>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：

　　add()方法会抛出异常

　　offer()方法返回false

　　put()方法会阻塞

 

 

**7.使用原子变量实现线程同步**

 

需要使用线程同步的根本原因在于对普通变量的操作不是原子的。

那么什么是原子操作呢？
原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作
即-这几种行为要么同时完成，要么都不完成。
在java的**util.concurrent.atomic包中提供了创建了原子类型变量的工具类**，
使用该类可以简化线程同步。
其中**AtomicInteger** 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，
但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。
**AtomicInteger类常用方法：**
AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicInteger
addAddGet(int dalta) : 以原子方式将给定值与当前值相加
get() : 获取当前值
**代码实例：**
只改Bank类，其余代码与上面第一个例子同

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 class Bank {
 2         private AtomicInteger account = new AtomicInteger(100);
 3 
 4         public AtomicInteger getAccount() {
 5             return account;
 6         }
 7 
 8         public void save(int money) {
 9             account.addAndGet(money);
10         }
11     } 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**补充--原子操作主要有：**
　　对于引用变量和大多数原始变量(long和double除外)的读写操作；
　　对于所有使用volatile修饰的变量(包括long和double)的读写操作。

# 什么情况下索引会失效



# Java常用设计模式

https://www.jianshu.com/p/61b67ca754a3



## **单例模式**

## **工厂模式**

## **观察者模式**

观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。

```java
package com.interfaces.test;

public interface Subject {
	/**
	 * 注册一个观察着
	 * @param observer
	 */
	public void registerObserver(Observer observer);
	/**
	 * 移除一个观察者
	 * 
	 * @param observer
	 */
	public void removeObserver(Observer observer);
 
	/**
	 * 通知所有的观察着
	 */
	public void notifyObservers();
}
```

```java
package com.interfaces.test;

import java.util.ArrayList;
import java.util.List;

public class ObjectFor3D implements Subject {

	private List<Observer> observers = new ArrayList<Observer>();
	/**
	 * 3D彩票的号码
	 */
	private String msg;

	@Override
	public void registerObserver(Observer observer) {
		observers.add(observer);
	}

	@Override
	public void removeObserver(Observer observer) {
		int index = observers.indexOf(observer);
		if (index >= 0) {
			observers.remove(index);
		}
	}

	@Override
	public void notifyObservers() {
		for (Observer observer : observers) {
			observer.update(msg);
		}
	}

	/**
	 * 主题更新消息
	 * @param msg
	 */
	public void setMsg(String msg) {
		this.msg = msg;

		notifyObservers();
	}
}
```

```java
package com.interfaces.test;

public interface Observer {
	public void update(String msg);
}
```

```java
package com.interfaces.test;

public class Observer1 implements Observer{

	private Subject subject;
	 
	public Observer1(Subject subject)
	{
		this.subject = subject;
		subject.registerObserver(this);//观察者设置主题，主题注册观察者
	}
 
	@Override
	public void update(String msg)
	{
		System.out.println("observer1 得到 3D 号码  -->" + msg + ", 我要记下来。");
	}
}
```

```java
package com.interfaces.test;

public class Observer2 implements Observer {
	private Subject subject;

	public Observer2(Subject subject) {
		this.subject = subject;
		subject.registerObserver(this);
	}
	@Override
	public void update(String msg) {
		System.out.println("observer2 得到 3D 号码 -->" + msg + "我要告诉舍友们。");
	}
}
```

```java
package com.interfaces.test;

public class Test {
	public static void main(String[] args) {
		//模拟一个3D的服务号
		ObjectFor3D subjectFor3d = new ObjectFor3D();
		//客户1
		new Observer1(subjectFor3d);
		new Observer2(subjectFor3d);
		subjectFor3d.setMsg("20140421的3D号码是：333");
	}
}
```



## **代理模式**

## 适配器模式

## 模板模式

```java
package com.spi;

import java.util.Date;

public abstract class Worker {
	protected String name;
	 
	public Worker(String name)
	{
		this.name = name;
	}
 
	/**
	 * 记录一天的工作
	 */
	public final void workOneDay()
	{
 
		System.out.println("-----------------work start ---------------");
		enterCompany();
		computerOn();
		work();
		computerOff();
		exitCompany();
		System.out.println("-----------------work end ---------------");
 
	}
 
	/**
	 * 工作
	 */
	public abstract void work();
 
	/**
	 * 关闭电脑
	 */
	private void computerOff()
	{
		System.out.println(name + "关闭电脑");
	}
 
	/**
	 * 打开电脑
	 */
	private void computerOn()
	{
		System.out.println(name + "打开电脑");
	}
 
	/**
	 * 进入公司
	 */
	public void enterCompany()
	{
		System.out.println(name + "进入公司");
	}
 
	public boolean isNeedPrintDate()
	{
		return false;
	}
	
	/**
	 * 离开公司
	 */
	public void exitCompany()
	{
		if (isNeedPrintDate())
		{
			System.out.print(new Date().toLocaleString()+"-->");
		}
		System.out.println(name + "离开公司");
	}
}
```

```java
package com.spi;

public class ITWorker extends Worker {

	public ITWorker(String name) {
		super(name);
	}

	@Override
	public void work() {
		System.out.println(name + "写程序-测bug-fix bug");
	}
	
	@Override
	public boolean isNeedPrintDate()
	{
		return true;
	}
}
```

```java
package com.spi;

public class HRWorker extends Worker {
	public HRWorker(String name) {
		super(name);
	}

	@Override
	public void work() {
		System.out.println(name + "看简历-打电话-接电话");
	}
}
```

```java
package com.spi;

public class QAWorker extends Worker {

	public QAWorker(String name) {
		super(name);
	}

	@Override
	public void work() {
		System.out.println(name + "写测试用例-提交bug-写测试用例");
	}
}
```

```java
package com.spi;

public class Test {
	public static void main(String[] args)
	{
 
		Worker it1 = new ITWorker("鸿洋");
		it1.workOneDay();
		Worker hr = new HRWorker("迪迪");
		hr.workOneDay();
		Worker qa = new QAWorker("老李");
		qa.workOneDay();
	}
}
```

## 装饰者模式

https://blog.csdn.net/lmj623565791/article/details/24269409



# HashMap数据结构

HashMap 是一个用于存储Key-Value键值对的集合，每一个键值对也叫做 Entry

这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干

HashMap 数组每一个元素的初始值都是 Null。

![è¿éåå¾çæè¿°](http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGrEuiawAiaywBA7HecrWicr59BcnqexdaBJWTRg49BUllBvVYfOC2Swkhe8PIKGa7gGpWYibxhCG5g1hQ/0?wx_fmt=png)

## Put 方法的原理

比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：

**index = Hash（“apple”）**

假定最后计算出的index是2，那么结果如下：

![这里写图片描述](http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2jxYh5D3F0avyBppia3BKHO3EU1HqbdThUMS3H9ejwb7ibu4bUiaOnsXqQ/0?wx_fmt=png)



但是，因为 HashMap 的长度是有限的，当插入的 Entry 越来越多时，再完美的 Hash 函数也难免会出现 index 冲突的情况。

比如下面这样： 
![这里写图片描述](http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2q93ezXuibE4fQjQpnDMTVlQgSFJmfsYypdxVibAcQeeLsHUCUd4m7tlg/0?wx_fmt=png)



这时候该怎么办呢？我们可以利用链表来解决。

HashMap 数组的每一个元素不止是一个 Entry 对象，也是一个链表的头节点。

每一个 Entry 对象通过 Next 指针指向它的下一个 Entry 节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可： 
![这里写图片描述](http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm29aBmKLDfHETNia2Lzpuia9tm9IDX5XXue0nGoSgFpUGT0crAS45zICQQ/0?wx_fmt=png)

需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。

## Get方法的原理

使用 Get 方法根据 Key 来查找 Value 的时候，发生了什么呢？

首先会把输入的 Key 做一次 Hash 映射，得到对应的 index：

index = Hash（“apple”）

由于刚才所说的 Hash 冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是 “apple”：

![这里写图片描述](http://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGoXt6UNkvyibQ8ufeF48pvm2ibC2cqrGyDNL5ms64Wqia4POibCU97PUNZiaSe2ectdgrBsgkGzKEnFOJw/0?wx_fmt=png)

第一步，我们查看的是头节点 Entry6，Entry6 的 Key是banana，显然不是我们要找的结果。

第二步，我们查看的是 Next 节点 Entry1，Entry1 的 Key 是 apple，正是我们要找的结果。

之所以把 Entry6 放在头节点，是因为 HashMap 的发明者认为，后插入的 Entry 被查找的可能性更大。



# synchronized

修饰静态方法

**实际上是对该类对象加锁，俗称“类锁”。**

**情况1**：用类直接在两个线程中调用两个不同的同步方法

**结果**：会产生互斥。

**解释**：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。

注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。

**情况2**：用一个类的静态对象在两个线程中调用静态方法或非静态方法

**结果**：会产生互斥。

**解释**：因为是一个对象调用，同上。

**情况3**：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法

**结果**：不会产生互斥。

**解释**：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。



例子：一个类中有两个静态方法都加了synchronized，则线程A没运行完其中一个方法时，其他线程不能访问另一个方法

```java
package com.spi;

public class Thread01 implements Runnable{

	@Override
	public void run() {
		try {
			SynchronizedTest.synchronized01();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```

```java
package com.spi;

public class Thread02 implements Runnable{

	@Override
	public void run() {
		SynchronizedTest.synchronized02();
	}
}
```

```java
package com.spi;

public class SynchronizedTest {
	
	public static  synchronized void synchronized01() throws InterruptedException {
		System.out.println("======synchronized01:"+System.currentTimeMillis());
		Thread.sleep(10000);
	}
    
	public static synchronized void synchronized02() {
		System.out.println("======synchronized02:"+System.currentTimeMillis());
	}
    
	public static void main(String[] args) {
		
		Thread thread01 = new Thread(new Thread01());
		thread01.start();
		Thread thread02 = new Thread(new Thread02());
		thread02.start();
	}
}
```

修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。一个类中有两个方法都加了synchronized，则线程A没运行完其中一个方法时，其他线程不能访问另一个方法

**情况1**：同一个对象在两个线程中分别访问该对象的两个同步方法

**结果**：会产生互斥。

**解释**：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。

**情况2**：不同对象在两个线程中调用同一个同步方法

**结果**：不会产生互斥。

**解释**：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，

```java
package com.spi;

public class Thread01 implements Runnable{
	SynchronizedTest synchronizedTest;
	Thread01(SynchronizedTest synchronizedTest){
		this.synchronizedTest = synchronizedTest;
	}
	@Override
	public void run() {
		try {
			synchronizedTest.synchronized01();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```

```java
package com.spi;

public class Thread02 implements Runnable {

	 SynchronizedTest synchronizedTest;
	 Thread02(SynchronizedTest synchronizedTest) {
	   this.synchronizedTest = synchronizedTest;
	}

	@Override
	public void run() {
		synchronizedTest.synchronized02();
	}
}
```

```java
package com.spi;

public class SynchronizedTest {
	
	public synchronized void synchronized01() throws InterruptedException {
		System.out.println("======synchronized01:"+System.currentTimeMillis());
		Thread.sleep(10000);
	}
	
	public synchronized void synchronized02() {
		System.out.println("======synchronized02:"+System.currentTimeMillis());
	}
	
	
	public static void main(String[] args) {
		
		SynchronizedTest synchronizedTest = new SynchronizedTest();
		
		Thread thread01 = new Thread(new Thread01(synchronizedTest));
		thread01.start();
		
		Thread thread02 = new Thread(new Thread02(synchronizedTest));
		thread02.start();
	}
}
```

总结：

​    1.对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性

​    2.在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。

​    3.关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。

​    4.静态方法加锁，能和所有其他静态方法加锁的 进行互斥

​    5.静态方法加锁，和xx.class 锁效果一样，直接属于类的



# ReentrantLock 可重入锁

若一个程序或子程序可以“安全的被并行执行(Parallel computing)”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，可以再次进入并执行它（并行执行时，个别的执行结果，都符合设计时的预期）。可重入概念是在单线程操作系统的时代提出的。

```java
package com.spi;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest implements Runnable {
	public static ReentrantLock lock = new ReentrantLock();
	public static int i = 0;

	@Override
	public void run() {
		for (int j = 0; j < 100000; j++) {
			lock.lock();
			try {
				i++;
			} finally {
				lock.unlock();
			}
		}
	}

	public static void main(String[] args) throws InterruptedException {
		
		ReentrantLockTest test = new ReentrantLockTest();
		
		Thread t1 = new Thread(test);
		Thread t2 = new Thread(test);
		
		t1.start();
		t2.start();
		t1.join();
		t2.join();//main线程会等待t1和t2都运行完再执行以后的流程
		System.out.println(i);
	}
}
```

## **中断响应**

对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。直接上代码，来演示使用重入锁如何解决死锁：

## **公平锁**

所谓公平锁，就是按照时间先后顺序，使先等待的线程先得到锁，而且，公平锁不会产生饥饿锁，也就是只要排队等待，最终能等待到获取锁的机会。使用重入锁（默认是非公平锁）创建公平锁：

```java
package com.spi;

import java.util.concurrent.locks.ReentrantLock;

public class FairLockTest implements Runnable{
    public static ReentrantLock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            try {
                lock.lock();
                System.err.println(Thread.currentThread().getName() + "获取到了锁！");
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        FairLockTest test = new FairLockTest();
        Thread t1 = new Thread(test, "线程1");
        Thread t2 = new Thread(test, "线程2");
        t1.start();
        t2.start();
    }
}
```

```shell
线程1获取到了锁！
线程2获取到了锁！
线程1获取到了锁！
线程2获取到了锁！
线程1获取到了锁！
线程2获取到了锁！
线程1获取到了锁！
线程2获取到了锁！
线程1获取到了锁！
```

可以发现，t1和t2交替获取到锁。如果是非公平锁，会发生t1运行了许多遍后t2才开始运行的情况。

## **ReentrantLock 配合 Conditond **

配合关键字synchronized使用的方法如：await()、notify()、notifyAll()，同样配合ReentrantLock 使用的Conditon提供了以下方法：

```
public interface Condition {
    void await() throws InterruptedException; // 类似于Object.wait()
    void awaitUninterruptibly(); // 与await()相同，但不会再等待过程中响应中断
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal(); // 类似于Obejct.notify()
    void signalAll();
}
```

```java
package com.spi;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockWithConditon implements Runnable{
    public static ReentrantLock lock = new ReentrantLock(true);
    public static Condition condition = lock.newCondition();

    @Override
    public void run() {
        lock.newCondition();
        try {
            lock.lock();
            System.err.println(Thread.currentThread().getName() + "-线程开始等待...");
            condition.await();
            System.err.println(Thread.currentThread().getName() + "-线程继续进行了");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReentrantLockWithConditon test = new ReentrantLockWithConditon();
        Thread t = new Thread(test, "线程ABC");
        t.start();
        Thread.sleep(1000);
        System.err.println("过了1秒后...");
        lock.lock();
        condition.signal(); // 调用该方法前需要获取到创建该对象的锁否则会产生
        lock.unlock();
    }
}
```

## 使用场景

**如果发现该操作已经在执行中则不再执行（有状态执行）**

a、用在定时任务时，如果任务执行时间可能超过下次计划执行时间，确保该有状态任务只有一个正在执行，忽略重复触发。 
b、用在界面交互时点击执行较长时间请求操作时，防止多次点击导致后台重复执行（忽略重复触发）。

以上两种情况多用于进行非重要任务防止重复执行，（如：清除无用临时文件，检查某些资源的可用性，数据备份操作等）



**场景1：如果已加锁，则不再重复加锁**

```java
package com.spi;
import java.util.concurrent.locks.ReentrantLock;
public class ReentrantLockTest implements Runnable {
	public static ReentrantLock lock = new ReentrantLock();
	public static void main(String[] args) throws InterruptedException {
		ReentrantLockTest reentrantLockTest = new ReentrantLockTest();
		Thread thread = new Thread(reentrantLockTest);
		thread.start();
		thread = new Thread(reentrantLockTest);
		thread.start();
	}
	@Override
	public void run() {
		if (lock.tryLock()) {//如果已经被lock，则返回false
             
			try {
				System.out.println("====================");
			} finally {
				lock.unlock();
			}
		}
	}
}
```

**场景2：如果发现该操作已经在执行，则尝试等待一段时间，等待超时则不执行（尝试等待执行）**

```java
package com.spi;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockTest implements Runnable {

	public static ReentrantLock lock = new ReentrantLock();

	public static void main(String[] args) throws InterruptedException {

		ReentrantLockTest reentrantLockTest = new ReentrantLockTest();
		Thread thread = new Thread(reentrantLockTest);
		thread.start();
		thread = new Thread(reentrantLockTest);
		thread.start();
	}
    
	@Override
	public void run() {
		try {
			if (lock.tryLock(5, TimeUnit.SECONDS)) {///如果已经被lock，尝试等待5s，看是否可以获得锁，如果5s后仍然无法获得锁则返回false继续执行
				try {
					System.out.println("====================");
				} finally {
					Thread.sleep(4000);
					lock.unlock();
				}
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```

**公平锁和非公平锁**

Lock有更灵活的锁定方式，公平锁与不公平锁，而synchronized永远是公平的。

```
private ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁
private ReentrantLock lock = new ReentrantLock(true); //公平锁
try {
    lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果
   //操作
} finally {
    lock.unlock();
}
```

不公平锁与公平锁的区别：

公平情况下，操作会排一个队按顺序执行，来保证执行顺序。（会消耗更多的时间来排队）
不公平情况下，是无序状态允许插队，jvm会自动计算如何处理更快速来调度插队。（如果不关心顺序，这个速度会更快）



# synchronized原理

> synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 

1. 普通同步方法，锁是当前实例对象 
2. 静态同步方法，锁是当前类的class对象 
3. 同步方法块，锁是括号里面的对象

# Java 技术之垃圾回收机制

## 什么是 Java 堆内存

堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的`对象和数组`都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。

因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。

## 那什么是垃圾呢？

所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。

### 引用计数法

为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。

因此，Java 里没有采用这样的方案来判定对象的“存活性”。

### 可达性分析

这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。



# java堆和栈

基本数据类型、局部变量都是存放在栈内存中的，用完就消失。
new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。

**栈和堆的特点**

**栈：**

函数中定义的基本类型变量，对象的引用变量都在函数的栈内存中分配。
栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。
栈内存中的数据，没有默认初始化值，需要手动设置。

**堆：**

堆内存用来存放new创建的对象和数组。
堆内存中所有的实体都有内存地址值。
堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。
堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）。

# HashMap查询复杂度

面试中问到`HashMap`查询的**时间复杂度**，第一反应:查询复杂度是什么。

查找资料显示，HashMap查询的**时间复杂度**理想情况下为O(1),HashMap在**Hash冲突**时使用了链表，这会导致数据量大的时候，链表较长，查询的**时间复杂度**为O(n),避免这种情况可以使用优秀的**Hash算法**，尽可能减少**Hash冲突**。

# SpringBoot优势

1.帮助开发者快速搭建Spring框架，无需配置自动整合第三方框架。

2.帮助开发者快速启动一个web容器，内嵌servlet容器，降低了对环境的要求，可以使用命令直接执行项目，应用可用jar包执行：java -jar。

3.继承了原有的Spring框架的优秀基因。

4.简化了Spring的使用过程，提高了开发效率。

5.提供了starter POM，可以非常方便 的对包进行管理，极大程度的减少了jar hell 和dependency hell。

6.运行中对应用状态的监控。



# dubbo最底层的协议

使用dubbo。使用rpc协议进行远程调用，直接使用socket通信。传输效率高，并且可以统计出系统之间的调用关系、调用次数。

Socket 是一种应用接口, TCP/IP 是网络传输协议，虽然接口相同, 但是不同的协议会有不同的服务性质。创建Socket 连接时，可以指定使用的传输层协议，Socket 可以支持不同的传输层协议（TCP 或UDP ），当使用TCP 协议进行连接时，该Socket 连接就是一个TCP 连接。Soket 跟TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。所以，socket 的出现只是可以更方便的使用TCP/IP 协议栈而已。



# static方法

如果父类的方法是静态的static，则子类不能覆盖

Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。



# linux面试题

1：查看8080端口被谁占用   netstat   -anp   |   grep  8080

